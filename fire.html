<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>


</head>

<body>
    <canvas id="myCanvas" width="300" height="700" style="border:1px solid #c3c3c3;">
        Your browser does not support the canvas element.
    </canvas>
</body>
<script>




    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext("2d");
    const maxRandomness = 3000;
    const widhth = 300
    const height = 700

    class matching {


        CONTOURS = [
            [], // 0
            [
                { x: 0, y: 100, yi: -1 },
                { x: 0.5, y: 1, xi: 1 },
                { x: 0, y: 1 },
            ], // 1
            [
                { x: 0.5, xi: -1, y: 1 },
                { x: 1, y: 0.5, yi: -1 },
                { x: 1, y: 1 },
            ], // 2
            [
                { x: 0.0, y: 1 },
                { x: 0, y: 0.5, yi: -1 },
                { x: 1, y: 0.5, yi: -1 },
                { x: 1, y: 1 },
            ], // 3
            [
                { x: 0.5, xi: -1, y: 0 },
                { x: 1, y: 0 },
                { x: 1, y: 0.5, yi: 1 },
            ], // 4
            [
                { x: 0, y: 1 },
                { x: 0, y: 0.5, yi: -1 },
                { x: 0.5, xi: -1, y: 0 },
                { x: 1, y: 0 },
                { x: 1, y: 0.5, yi: 1 },
                { x: 0.5, xi: 1, y: 1 },
            ], // 5 saddle point
            [
                { x: 0.5, xi: -1, y: 0 },
                { x: 0.5, xi: -1, y: 1 },
                { x: 1, y: 1 },
                { x: 1, y: 0 },
            ], // 6
            [
                { x: 0, y: 0.5, yi: -1 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
                { x: 1, y: 0 },
                { x: 0.5, xi: -1, y: 0 },
            ], // 7
            [
                { x: 0, y: 0.5, yi: 1 },
                { x: 0.5, xi: 1, y: 0 },
                { x: 0, y: 0 },
            ], // 8
            [
                { x: 0.5, xi: 1, y: 0 },
                { x: 0.5, xi: 1, y: 1 },
                { x: 0, y: 1 },
                { x: 0, y: 0 },
            ], // 9
            [
                { x: 0, y: 0 },
                { x: 0.5, xi: 1, y: 0 },
                { x: 1, y: 0.5, yi: -1 },
                { x: 1, y: 1 },
                { x: 1, y: 0.5, yi: -1 },
                { x: 1, y: 1 },
                { x: 0.5, xi: -1, y: 1 },
                { x: 0, y: 0.5, yi: 1 },
            ], // 10 saddle point
            [
                { x: 0.5, xi: 1, y: 0 },
                { x: 0, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
                { x: 1, y: 0.5, yi: -1 },
            ], // 11
            [
                { x: 0.0, y: 0 },
                { x: 1, y: 0 },
                { x: 1, y: 0.5, yi: 1 },
                { x: 0, y: 0.5, yi: 1 },
            ], // 12
            [
                { x: 0.5, xi: 1, y: 1 },
                { x: 0, y: 1 },
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 1, y: 0.5, yi: 1 },
            ], // 13
            [
                { x: 0, y: 0.5, yi: 1 },
                { x: 0.5, xi: -1, y: 1 },
                { x: 1, y: 1 },
                { x: 1, y: 0 },
                { x: 0, y: 0.0 },
            ], // 14
            [
                { x: 0, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
                { x: 1, y: 0 },
            ], // 15
        ];

        isSaddlePoint(point) {
            return point === 5 || point === 10;
        }

        /**
         * Flip point
         */


        resolveSaddlePointWithAvg(point, avg, threshold) {
            if (avg >= threshold) {
                if (point === 5) {
                    return 10;
                }
                if (point === 10) {
                    return 5;
                }
            }
            return point;
        }

        getInterpolatedPoint(point, originalValues, threshold) {
            let o = originalValues;
            let avg = (o[0] + o[1] + o[2] + o[3]) / 4;
            let cont = this.CONTOURS[point];
            let ret = [];
            let c;
            let i;
            let x;
            let y;
            let f;

            function makeF(avg) {
                return Math.min(1, avg / threshold) - 0.5;
            }

            f = makeF(avg);

            function ip(val, intf, f) {
                // interpolate
                if (intf) {
                    if (intf > 0) {
                        return val + f;
                    } else {
                        return val - f;
                    }
                }
                return val;
            }
            for (i = 0; i < cont.length; i++) {
                c = cont[i];
                if (c.xi) {
                    if (c.y === 0) {
                        x = ip(c.x, c.xi, makeF((o[0] + o[1]) / 2));
                    } else if (c.y === 0.5) {
                        x = ip(c.x, c.xi, f);
                    } else if (c.y === 1) {
                        x = ip(c.x, c.xi, makeF((o[2] + o[3]) / 2));
                    } else {
                        x = ip(c.x, c.xi, f);
                    }
                } else {
                    x = ip(c.x, c.xi, f);
                }
                if (c.yi) {
                    if (c.x === 0) {
                        y = ip(c.y, c.yi, makeF((o[0] + o[3]) / 2));
                    } else if (c.x === 0.5) {
                        y = ip(c.y, c.yi, f);
                    } else if (c.x === 1) {
                        y = ip(c.y, c.yi, makeF((o[1] + o[2]) / 2));
                    } else {
                        y = ip(c.y, c.yi, f);
                    }
                } else {
                    y = ip(c.y, c.yi, f);
                }

                ret.push({ x: x, y: y });
            }
            if (point === 15) {
                ret[0].fullsquare = true;
            }

            return ret;
        }



        calculateAllWithInterpolation = function (grid, threshold) {
            let x;
            let y;
            let line1;
            let line2;
            let retGrid = [];
            let retLine;
            let point;
            let avg;

            const th = function (val) {
                return val >= threshold ? 1 : 0;
            };

            for (y = 0; y < grid.length - 1; y++) {
                line1 = grid[y];
                line2 = grid[y + 1];
                retLine = [];
                for (x = 0; x < line1.length - 1; x++) {
                    point =
                        (th(line1[x]) << 3) |
                        (th(line1[x + 1]) << 2) |
                        (th(line2[x + 1]) << 1) |
                        th(line2[x]);
                    avg = (line1[x] + line1[x + 1] + line2[x + 1] + line2[x]) / 4;
                    point = this.resolveSaddlePointWithAvg(point, avg, threshold);
                    retLine.push(
                        this.getInterpolatedPoint(
                            point,
                            [line1[x], line1[x + 1], line2[x + 1], line2[x]],
                            threshold
                        )
                    );
                }
                retGrid.push(retLine);
            }

            return retGrid;
        }
    }

    let marching = new matching()
    class Fire {
        p = function (n) {
            return {
                key: `l${n}`,
                max: 100,
                min: 0,
            };
        }

        c = function (n) {
            return {
                key: `c${n}`,

            };
        }
        properties = [
            this.c(1),
            this.c(2),
            this.c(3),
            this.c(4),
            this.c(5),
            this.p(1),
            this.p(2),
            this.p(3),
            this.p(4),
            this.p(5),
        ]

        label = "Fire using marching squares"
        x = 200
        y = 0
        height = 81
        zindex = 1
        width = 210
        blocksize = 6
        burnfactor = 131
        fuel = 15
        c1 = "#fffEFF"
        c2 = "#E2F2FF"
        c3 = "#e220FF"
        c4 = "#9b11FF"
        c5 = "#0000FF"
        l1 = 100
        l2 = 64
        l3 = 35
        l4 = 22
        l5 = 11
        runsimulation = 1
        useintensitymodulation = 0
        dopaint = 1
        optimize_onlysquares = false
        optimize_rle_squares = true
        optimize_removedoubles = false
        optimize_batchfill = true
        debug_drawmesh = false

        grid = []

        initialize = function () {
            this.initValues();
        }

        initValues = function () {
            this.grid = [];
            this.burnoffset = 0;
            this.mytick = 60;
            this._boost = 0;
        }
        //wtf is offset
        updateBurnOffset = function () {
            this.mytick = ((this.mytick || 0) + 0.4) % 100;
            if (this.mytick > 85) {
                this.burnoffset += Math.random() * 0.1;
            }
            if (this.mytick < 50) {
                this.burnoffset *= 0.95;
            }
        }



        paint = function (ctx) {
            let i;
            let c;
            let g;
            let line;
            let point;
            let startx;
            let width;
            let l;
            let x;
            let y;
            let grids = [];

            if (!this.dopaint) {
                return;
            }

            ctx.translate(this.x, this.y);

            for (i = 1; i <= 5; i++) {
                l = this[`l${i}`];
                grids.push(
                    marching.calculateAllWithInterpolation(this.grid, l / 100)
                );
            }

            if (this.optimize_removedoubles) {
                this.erasePaintDoubles(grids);
            }
            //podle poctu barev 
            for (i = 5; i > 0; i--) {
                l = this[`l${i}`];
                c = this[`c${i}`];
                ctx.fillStyle = c;
                if (this.optimize_batchfill) {
                    ctx.beginPath();
                }
                g = grids[i - 1];

                for (y = 0; y < g.length; y++) {
                    line = g[y];
                    for (x = 0; x < line.length; x++) {
                        point = line[x];
                        if (point && point.length > 0) {
                            // RLE squares
                            //optimalizace, ani nevim ceho
                            if (true) {
                                if (point[0].fullsquare) {
                                    startx = x;
                                    width = 0;
                                    while (
                                        x < line.length &&
                                        line[x] &&
                                        line[x][0] &&
                                        line[x][0].fullsquare
                                    ) {
                                        x++;
                                        width++;
                                    }
                                    if (width > 0) {
                                        if (startx + width >= line.length) {
                                            width = line.length - startx - 1;
                                        }
                                        this.drawRect(
                                            ctx,
                                            startx,
                                            y,
                                            width + 1,
                                            1,
                                            this.optimize_batchfill
                                        );
                                        continue;
                                    }
                                }
                            }

                            if (this.optimize_onlysquares) {
                                this.drawRect(ctx, x, y, 1, 1, this.optimize_batchfill);
                            } else {
                                //vykresleni tamtech specialnich ctvercu
                                // this.drawContour(ctx, point, x, y, this.optimize_batchfill);
                                this.drawRect(ctx, x, y, 1, 1, this.optimize_batchfill);
                            }
                        }
                    }
                }
                if (true) {
                    ctx.fill();
                }
            }
            //vykresleni meshu
            if (this.debug_drawmesh) {
                this.drawMesh(ctx, grids[0][0].length, grids[0].length);
            }
            ctx.translate(-this.x, -this.y);
        }

        drawRect = function (ctx, x, y, width, height = 1, dontFill) {
            let xoffset;
            let yoffset;
            let b = this.blocksize;
            xoffset = b * x;
            yoffset = b * y;
            if (!dontFill) {
                ctx.beginPath();
            }
            ctx.rect(xoffset, yoffset, width * b, height * b);
            if (!dontFill) {
                ctx.fill();
            }
        }


        boost = function () {
            this._boost += 10;
        }


        tick = function (ctx, diff) {
            let grid = []
            var ms;

            var x;
            var y;
            var lower;
            var upper;
            var lastLine;
            var burnfactor =
                (this.burnfactor +
                    (this.useintensitymodulation ? this.burnoffset : 0) +
                    this._boost) /
                100;
            var fuel = this.fuel / 100;
            var TICK_MS = 20;
            // i dont fcking know what does this change
            if (!this.runsimulation) {
                if (this.grid.length < this.height) {
                    this.grid = this.createGrid(this.height);
                }
                return;
            }

            this.ms = (this.ms || 0) + diff;
            //changing burn computation
            function processLine(lower, upper) {

                var n;
                var length = lower.length;
                var sum;
                for (x = 0; x < length; x++) {
                    sum = 0;
                    n = x - 1;
                    sum += (lower[n] || 0) + (lower[n + 1] || 0) + (lower[n + 2] || 0);
                    sum += (upper[n] || 0) + (upper[n + 1] || 0) + (upper[n + 2] || 0);
                    upper[x] = sum * 0.167 * burnfactor * (0.5 + Math.random() * 0.5);
                }

            }

            if (this.grid.length < this.height) {
                this.grid = this.createGrid(this.height);
            }

            while (this.ms > TICK_MS) {
            
                for (y = 0; y < this.grid.length - 1; y++) {
                    lower = this.grid[y + 1];
                    upper = this.grid[y];
                    processLine(lower, upper);
                    
                }
                lastLine = this.grid[this.grid.length - 1];
                const newLine = [];
                for (x = 0; x < lastLine.length; x++) {
                    newLine.push(0.5 + Math.random() * fuel);
                }

                processLine(newLine, lastLine);
                this.ms = this.ms - TICK_MS;

                if (this.useintensitymodulation) {
                    this.updateBurnOffset();
                }
                //dont get it
                if (this._boost > 0) {
                    this._boost -= 1;
                }

            }

        }

        createGrid = function (height) {
            let grid = [];
            let i;

            function makeLine(length) {
                let line = [];
                let j;
                for (j = 0; j < length; j++) {
                    line.push(0);
                }
                return line;
            }
            for (i = 0; i < height; i++) {
                grid.push(makeLine(this.width));
            }
            return grid;
        }

        onPropertyUpdate = function (name, value) {
            this[name] = value;
            if (name === "height" || name === "width") {
                this.grid = [];
            }
        }
    }


    frameloop = function (ctx, mainobj) {




        let animate;
        let lastTs = new Date();
        let s = 0;
        let pause;
        let frames = 0;



        animate = function () {
            let curTs = new Date() - 0;
            let diff = curTs - lastTs;
            let report = "";
            let logStr;
            setTimeout(animate);
            lastTs = curTs;
            s = s + diff;
            frames++;
            if (s >= 1000) {




                s = 0;
                frames = 0;
            }

            //vykreslení a výpočet

            mainobj.tick(ctx, diff);


            mainobj.paint(ctx);

        };

        animate();
    };








    frameloop(ctx, new Fire())

</script>

</html>