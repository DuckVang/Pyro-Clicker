<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Page Title</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>


</head>

<body>
    <canvas id="myCanvas" width="300" height="700" style="border:1px solid #c3c3c3;">
        Your browser does not support the canvas element.
    </canvas>
</body>
<script>




    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext("2d");
    const maxRandomness = 3000;
    const widhth = 300
    const height = 700


    class Fire {
        p = function (n) {
            return {
                key: `l${n}`,
                max: 100,
                min: 0,
            };
        }

        c = function (n) {
            return {
                key: `c${n}`,

            };
        }
        properties = [
            this.c(1),
            this.c(2),
            this.c(3),
            this.c(4),
            this.c(5),
            this.p(1),
            this.p(2),
            this.p(3),
            this.p(4),
            this.p(5),
        ]

        label = "Fire using marching squares"
        x = 200
        y = 0
        height = 81
        zindex = 1
        width = 210
        blocksize = 6
        burnfactor = 131
        fuel = 15
        c1 = "#fffEFF"
        c2 = "#E2F2FF"
        c3 = "#e220FF"
        c4 = "#9b11FF"
        c5 = "#0000FF"
        l1 = 100
        l2 = 64
        l3 = 35
        l4 = 22
        l5 = 11
        runsimulation = 1
        useintensitymodulation = 0
        dopaint = 1
        optimize_onlysquares = false
        optimize_rle_squares = true
        optimize_removedoubles = false
        optimize_batchfill = true
        debug_drawmesh = false

        initialize = function () {
            this.initValues();
        }

        initValues = function () {
            this.grid = [];
            this.burnoffset = 0;
            this.mytick = 60;
            this._boost = 0;
        }
        //wtf is offset
        updateBurnOffset = function () {
            this.mytick = ((this.mytick || 0) + 0.4) % 100;
            if (this.mytick > 85) {
                this.burnoffset += Math.random() * 0.1;
            }
            if (this.mytick < 50) {
                this.burnoffset *= 0.95;
            }
        }

        report = function () {
            const ret = _c.fmt(
                "Fire {}, {}",
                Math.round(this.maxIntensity * 100),
                Math.round(this.minIntensity * 100)
            );
            this.maxIntensity = undefined;
            this.minIntensity = undefined;
            return ret;
        }

        paint = function (ctx) {
            let i;
            let c;
            let g;
            let line;
            let point;
            let startx;
            let width;
            let l;
            let x;
            let y;
            let grids = [];

            if (!this.dopaint) {
                return;
            }

            ctx.translate(this.x, this.y);

            for (i = 1; i <= 5; i++) {
                l = this[`l${i}`];
                grids.push(
                    CB.Marchingsquares.calculateAllWithInterpolation(this.grid, l / 100)
                );
            }

            if (this.optimize_removedoubles) {
                this.erasePaintDoubles(grids);
            }
            //podle poctu barev 
            for (i = 5; i > 0; i--) {
                l = this[`l${i}`];
                c = this[`c${i}`];
                ctx.fillStyle = c;
                if (this.optimize_batchfill) {
                    ctx.beginPath();
                }
                g = grids[i - 1];

                for (y = 0; y < g.length; y++) {
                    line = g[y];
                    for (x = 0; x < line.length; x++) {
                        point = line[x];
                        if (point && point.length > 0) {
                            // RLE squares
                            //optimalizace, ani nevim ceho
                            if (true) {
                                if (point[0].fullsquare) {
                                    startx = x;
                                    width = 0;
                                    while (
                                        x < line.length &&
                                        line[x] &&
                                        line[x][0] &&
                                        line[x][0].fullsquare
                                    ) {
                                        x++;
                                        width++;
                                    }
                                    if (width > 0) {
                                        if (startx + width >= line.length) {
                                            width = line.length - startx - 1;
                                        }
                                        this.drawRect(
                                            ctx,
                                            startx,
                                            y,
                                            width + 1,
                                            1,
                                            this.optimize_batchfill
                                        );
                                        continue;
                                    }
                                }
                            }

                            if (this.optimize_onlysquares) {
                                this.drawRect(ctx, x, y, 1, 1, this.optimize_batchfill);
                            } else {
                                //vykresleni tamtech specialnich ctvercu
                                // this.drawContour(ctx, point, x, y, this.optimize_batchfill);
                                this.drawRect(ctx, x, y, 1, 1, this.optimize_batchfill);
                            }
                        }
                    }
                }
                if (true) {
                    ctx.fill();
                }
            }
            //vykresleni meshu
            if (this.debug_drawmesh) {
                this.drawMesh(ctx, grids[0][0].length, grids[0].length);
            }
            ctx.translate(-this.x, -this.y);
        }

        drawRect = function (ctx, x, y, width, height = 1, dontFill) {
            let xoffset;
            let yoffset;
            let b = this.blocksize;
            xoffset = b * x;
            yoffset = b * y;
            if (!dontFill) {
                ctx.beginPath();
            }
            ctx.rect(xoffset, yoffset, width * b, height * b);
            if (!dontFill) {
                ctx.fill();
            }
        }


        boost = function () {
            this._boost += 10;
        }


        tick = function (ctx, diff) {
            var ms;

            var x;
            var y;
            var lower;
            var upper;
            var lastLine;
            var burnfactor =
                (this.burnfactor +
                    (this.useintensitymodulation ? this.burnoffset : 0) +
                    this._boost) /
                100;
            var fuel = this.fuel / 100;
            var TICK_MS = 20;
            // i dont fcking know what does this change
            if (!this.runsimulation) {
                if (this.grid.length < this.height) {
                    this.grid = this.createGrid(this.height);
                }
                return;
            }

            this.ms = (this.ms || 0) + diff;
            //changing burn computation
            function processLine(lower, upper) {
                var n;
                var length = lower.length;
                var sum;
                for (x = 0; x < length; x++) {
                    sum = 0;
                    n = x - 1;
                    sum += (lower[n] || 0) + (lower[n + 1] || 0) + (lower[n + 2] || 0);
                    sum += (upper[n] || 0) + (upper[n + 1] || 0) + (upper[n + 2] || 0);
                    upper[x] = sum * 0.167 * burnfactor * (0.5 + Math.random() * 0.5);
                }

            }

            if (this.grid.length < this.height) {
                this.grid = this.createGrid(this.height);
            }

            while (this.ms > TICK_MS) {

                for (y = 0; y < this.grid.length - 1; y++) {
                    lower = this.grid[y + 1];
                    upper = this.grid[y];
                    processLine(lower, upper);
                }
                lastLine = this.grid[this.grid.length - 1];
                const newLine = [];
                for (x = 0; x < lastLine.length; x++) {
                    newLine.push(0.5 + Math.random() * fuel);
                }

                processLine(newLine, lastLine);
                this.ms = this.ms - TICK_MS;

                if (this.useintensitymodulation) {
                    this.updateBurnOffset();
                }
                //dont get it
                if (this._boost > 0) {
                    this._boost -= 1;
                }
            }
        }

        createGrid = function (height) {
            let grid = [];
            let i;

            function makeLine(length) {
                let line = [];
                let j;
                for (j = 0; j < length; j++) {
                    line.push(0);
                }
                return line;
            }
            for (i = 0; i < height; i++) {
                grid.push(makeLine(this.width));
            }
            return grid;
        }

        onPropertyUpdate = function (name, value) {
            this[name] = value;
            if (name === "height" || name === "width") {
                this.grid = [];
            }
        }
    }


    frameloop = function (ctx, mainobj) {
        let animate;
        let lastTs = new Date();
        let s = 0;
        let pause;
        let frames = 0;

     

        animate = function () {
            let curTs = new Date() - 0;
            let diff = curTs - lastTs;
            let report = "";
            let logStr;
            setTimeout(animate, pause ? WAITMS_PAUSE : WAITMS_RUN);
            lastTs = curTs;
            s = s + diff;
            frames++;
            if (s >= 1000) {
                if (mainobj.report) {
                    report = mainobj.report();
                }
                logStr = `FPS: ${frames}${report ? `, ${report}` : ""}`;
                if (ctrl) {
                    ctrl.showLog(logStr);
                }
                if (fpsfunc) {
                    fpsfunc(frames);
                }
                s = 0;
                frames = 0;
            }

            //vykreslení a výpočet
            if (!pause) {
                mainobj.tick(ctx, diff);
            }
            if (mainobj.draw) {
                mainobj.draw(ctx);
            }
        };

        animate();
    };
    frameloop(ctx,new Fire())

</script>

</html>